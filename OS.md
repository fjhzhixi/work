# 引论

## 操作系统定义

操作系统是一组管理计算机硬件资源的软件集合,向计算机程序提供共性的服务

* 对**使用者**提供用户与硬件系统的接口方便使用
* 作为**资源管理者**控制和管理各种软硬件资源提高利用率
* 合理组织计算机系统的工作流程,改善系统性能

**操作系统的设计目标**也就对应着 :

1. 使使用者方便
2. 使系统的资源利用率尽可能高

## 系统层次

1. 自顶向下看 : 管理复杂的硬件资源,**使用抽象屏蔽复杂性**
2. 自底向上看 : 向上层应用提供服务,支持多个用户,多个程序,实现资源的共享

## 作用

1. 用户与计算机硬件系统之间的接口
2. 系统资源的管理者
3. 实现对计算机资源的抽象(虚拟机)

## 冯诺依曼计算机的主要特点

**存储程序**思想 :

1. 计算机应用包括运算器、控制器、存储器、输入/输出设备.
2. 计算机内部应采用二进制来表示指令和数据
3. 将程序和数据送会内存储器，然后计算机自动地逐条取出指令和数据进行分析、处理和执行。

之后的哈佛结构改进将**程序指令与数据分开存储**

## 晶体管时代的批处理系统

又名监控系统,**主要解决了高速`CPU`与低速`I/O`设备之间的矛盾**

1. 定义 : 将用户提交的作业成批送入计算机,由作业调度程序自动选择作业运行

2. 目的 : 

   * 缩短作业之间的交接时间
   * 减少处理机的空闲等待,提高系统效率

3. **发展阶段** : 

   1. **联机批处理系统 ** : 作业的输入输出由主机`CPU`来处理

      ![1558918643435](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1558918643435.png)

      在批处理系统的控制下 : 

      1. **成批**的将输入机上的用户作业读入磁带中
      2. **依次**将磁带中的用户作业读入主机执行
      3. 计算结果输入到输出机
      4. 当一批作业处理完之后重复上述步骤

      优点 : 减少了手动切换作业时间,克服了人机矛盾

      不足 : **在作业的输入和结果输出时,主机的高速`CPU`处于忙等状态,所以引入了脱机批处理**

   2. **脱机批处理系统** : 输入输出脱离主机控制

      ![1558918926092](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1558918926092.png)

      **卫星机的功能** :

      1. 从输入机中读取用户作业并放到输入磁带上
      2. 从输出磁带中读取执行结果并传回输出机

      优点 : **主机可以与卫星机并行**,主机不需要与慢速的输入输出设备打交道,直接与高速磁带机交互,输入输出有卫星机控制

      不足 : **在主机中每次存放一道作业,在其运行期间发生`I/O`请求后高速`CPU`要等待低速`CPU`完成操作,处于空闲状态,所以引入了多道程序系统**

## 集成电路与多道程序设计

1. 定义 : 允许多个程序同时进入内存并运行,允许他们交替使用计算机资源,**当一个因`I/O`请求暂停时,将`CPU`资源分配给另一个程序**

2. **单处理机(即单核`CPU`)中多道程序运行** :

   1. 宏观上并行 : 均开始运行,均未结束运行
   2. 微观上串行 : 轮流使用`CPU`交替运行

3. 多道批处理系统 :

   * 多道 : 系统外存中容纳多个作业,由系统选择调度
   * 成批 : 作业进入系统后不允许用户干扰

   优点 : 系统吞吐量大,资源利用率高

   不足 : 平均周转周期长,**不能提供交互能力** (所以提出了**分时系统**)

## 分时系统

侧重点在于**交互性(即对用户请求的及时响应)**

1. 定义: 将`CPU`处理时间分割成多个时间片,将不同时间片分配给不同的程序达到程序同时运行的效果

2. 特点 :

   * 多路性 : 允许多个用户同时使用一台计算机,微观上轮流使用,宏观上用户并行使用

   * 交互性 : 根据请求响应

   * 独立性 : 各用户之间相互独立,互不干扰

   * 及时性 : 由**响应时间**衡量 : 从终端发出指令到系统给予应答的时间

     其影响因素有系统开销,用户数目,时间片长短,对换信息量等,通过**可重入代码,引入虚存减少对换**缩短

```flow
elem1=>start: 计算机
aim1=>operation: 解决人机矛盾
elem2=>start: 联机批处理
aim2=>operation: 解决输入输出时CPU处于忙等
elem3=>start: 脱机批处理
aim3=>operation: 解决单个作业I/O请求导致CPU等待
elem4=>start: 多道程序批处理
aim4=>operation: 解决交互性问题
elem5=>end: 分时系统
elem1(right)->aim1->elem2->aim2->elem3->aim3->elem4->aim4->elem5
```

**注意在选择设计时要注意需求**,例如 :

1. 对于大规模作业使用批处理
2. 对于对快速响应的交互性使用分时系统

## 异常

![1558923044094](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1558923044094.png)

**系统调用** : 系统调用把应用程序的请求传给内核，调用相应的的内核函数完成所需的处理，将处理结果返回给应用程序

## 操作系统的基本类型

1. 批处理系统
2. 分时系统
3. 实时系统
4. 混合型

## 操作系统的特征

* 并发
* 共享
* 虚拟
* 不确定

## 操作系统要解决的问题

1. 提供解决由资源竞争引起的各种冲突的策略
2. 协调并发活动
3. 保证数据的一致性
4. 实现数据的存取控制

## 操作系统的功能

* 处理机管理 : 进程的控制,同步,通信,调度
* 存储器管理 : 内存分配.内存保护,地址映射
* 设备管理 : 缓冲管理,设备分配,设备处理,虚拟设备
* 文件系统 : 文件读写,文件保护,用户接口

## 微内核结构

内核中只包含中断处理,进程通信,基本调度等功能,文件系统,内存管理,设备管理均以服务的形式在微内核中使用

# 启动

## 引导加载程序(Bootloader)

系统加电之后运行的第一段代码,一般分为两个阶段

1. `Boot` : 初始化一部分系统硬件使其运行(一般汇编,与体系结构关联)
2. `Loader` : 将操作系统映像加载到内存中并把控制权交给操作系统(一般`C`,可移植)

## MIPS启动

### 内存划分

![1558925513343](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1558925513343.png)

1. `kseg0`放操作系统核心,(存取经过`cache`),最高位清0映射
2. `kseg1`与`kseg0`映射到同一个物理空间(高三位清0映射),存取不经过`cache`,**`kseg1`是唯一在系统启动时可以使用的空间**

### 启动过程

```flow
st=>start: 上电
op1=>operation: Bootloader加载操作系统
op2=>operation: 操作系统引导
st->op1->op2
```

# 内存管理

## 大小端问题



## 存储管理基本概念

### 存储管理功能

* 存储分配与回收
* 地址变换
  1. 可执行文件生成时的链接技术
  2. 程序加载时的重定位技术
  3. 进程运行时的硬件与软件地址变化技术
* 存储共享与保护
* 存储器扩充

### 可执行文件

1. 可执行文件的生成 :

   1. 编译 : 由**源文件**编译为**目标文件**
   2. 链接 : 由**目标文件**链接为可执行文件,**本质就是把目标文件相同类型的`section`合并为可执行文件的一个`segement`**

   **在链接时,会在各个目标文件中填入缺省(即编译时未找到)的函数地址,这个过程就是重定位** :

   1. 在编译过程中会**记录未找到的定义所在的偏移量在符号表中**
   2. 在链接过程中会**遍历每个目标文件的符号表在全局范围内查找缺失定义**

2. 一个程序**在内存中**的构成 :

   1. `bss`段 : 未初始化的全局变量(**不再可执行文件中,由系统初始化**)
   2. `data`段 : 已经初始化的全局变量
   3. `text`段 : 代码段
   4. 堆 : 存放运行中动态分配的内存段
   5. 栈 : 存放,交换临时数据(局部变量)的内存区

3. 可执行文件的装载 :

   将`ELF`文件中`Type`为`Load`的`segement`加载到内存的指定位置

   **一个`segememt`在文件中的大小是小于等于其在内存中的大小的,多余的空间以补0填充**

   **可执行文件的装载中也存在重定向过程,本质是因为一个程序本身有自己的逻辑空间,但是加载到内存中去后又有物理地址,二者要契合就要进行修改或者映射**

### 重定向

1. 链接过程中 : 填写编译时没有找到定义的变量或者函数的地址
2. 加载过程中 : 对目标程序中的指令和数据地址的修改或映射过程
   * 静态重定位
   * 动态充定位

## 存储管理的目标

1. 从用户角度可以支配整个存储空间
2. 从计算机角度可以同时为多个用户提供服务

## 存储管理的原则

1. **地址独立** : 程序发出的地址与物理地址无关 
2. **地址保护** : 一个程序不能访问另一个程序的地址

## 基础内存管理

### 存储分配方式

* 直接指定 : 程序中的是实际地址
* 静态分配 : 程序在存储空间中的地址**在装入时**确定
* 动态分配 : 程序在存储空间中的地址**在装入时**确定,并且在执行过程中可以申请空间,在使用完之后可以释放

### 单道程序内存管理

1. **前提条件** : 
   * 内存中只有两个程序,用户程序与操作系统
   * 操作系统占据的空间固定
2. 管理方式 : **静态地址翻译**
   * 用户程序永远**加载到同一个指定位置**
   * 在**程序运行前可以计算出所有的物理地址(由加载器完成)**
3. 优点 : 无需地址翻译,运行速度快
4. 缺点 : 
   * 比物理内存大的程序无法加载运行
   * 单个程序占据资源造成资源浪费

### 多道程序内存管理

管理方式 : **分区式分配**

将内存分成**大小相等或者不等的分区**,其中操作系统占据一个,每个用户程序占据一个或者多个

#### 固定式分区

1. 划分方式 : 
   * 分区大小相等
   * 分区大小不等 : 多个小分区,适量中等分区,少量大分区
2. 分配方式 :
   * 单一队列 : 多个用户程序**排在一个队列中**等待分区
   * 多队列 : 给每个分区一个队列,**程序根据大小排在相应的队列中**
3. 优点 : 简单易于实现,开销小
4. 缺点 : 
   * **内碎片浪费**
   * 分区数目**限定了程序并发执行的数目**
5. **管理内存的数据结构**
   1. 位图表示法 : **每个分配单元使用一位来表示**
      - 优点 : 空间成本固定,与程序数目无关,操作简单
      - 缺点 : 没有容错能力
   2. 链表表示法 : **将分配单元按照是否空闲链接,一个节点为一个程序占据的连续分区数目或者为连续的空闲分区**
      - 优点 : 可以容错
      - 缺点 : 空间成本取决于内存中程序的数目,操作时间成本高

#### 可变式分区

1. 划分方式 : 分区的大小可以变换
2. 分配方式 : **依据程序的加载逐渐分配**
3. 优点 : **没有内碎片**
4. 缺点 : **有外碎片**
5. 管理内存的数据结构 : **已分配分区表与未分配分区表**
   * 每张表的表项为存储控制块
   * **空闲分区表的存储控制块使用前向和后向指针组织成链表结构**

### 顺序搜索的分配算法

在**分区表**结构下顺序搜索,使用于较小的系统(否则分区表很大)

**注意在分配之后一个分区的剩下空间仍然可以继续分配出去**

* 首次适应算法 : 低地址区域留下众多小的空闲分区
* 下次适应算法 : 
  1. 是存储空间的利用更加均衡,不致于在一端
  2. 导致缺失大的空闲分区
* 最佳适应算法 :使剩余的空闲区非常小,很难利用
* 最坏适应算法 : 当有大作业到来时申请很难被满足

### 索引搜索的分配算法

1. 将空闲分区按照容量大小分类
2. 对每个类别建立空闲区链表
3. 为多个空闲链表设立一张管理索引表

### 系统的碎片













