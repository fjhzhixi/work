# 引论

## 操作系统定义

操作系统是一组管理计算机硬件资源的软件集合,向计算机程序提供共性的服务

* 对**使用者**提供用户与硬件系统的接口方便使用
* 作为**资源管理者**控制和管理各种软硬件资源提高利用率
* 合理组织计算机系统的工作流程,改善系统性能

**操作系统的设计目标**也就对应着 :

1. 使使用者方便
2. 使系统的资源利用率尽可能高

## 系统层次

1. 自顶向下看 : 管理复杂的硬件资源,**使用抽象屏蔽复杂性**
2. 自底向上看 : 向上层应用提供服务,支持多个用户,多个程序,实现资源的共享

## 作用

1. 用户与计算机硬件系统之间的接口
2. 系统资源的管理者
3. 实现对计算机资源的抽象(虚拟机)

## 冯诺依曼计算机的主要特点

**存储程序**思想 :

1. 计算机应用包括运算器、控制器、存储器、输入/输出设备.
2. 计算机内部应采用二进制来表示指令和数据
3. 将程序和数据送会内存储器，然后计算机自动地逐条取出指令和数据进行分析、处理和执行。

之后的哈佛结构改进将**程序指令与数据分开存储**

## 晶体管时代的批处理系统

又名监控系统,**主要解决了高速`CPU`与低速`I/O`设备之间的矛盾**

1. 定义 : 将用户提交的作业成批送入计算机,由作业调度程序自动选择作业运行

2. 目的 : 

   * 缩短作业之间的交接时间
   * 减少处理机的空闲等待,提高系统效率

3. **发展阶段** : 

   1. **联机批处理系统 ** : 作业的输入输出由主机`CPU`来处理

      ![1558918643435](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1558918643435.png)

      在批处理系统的控制下 : 

      1. **成批**的将输入机上的用户作业读入磁带中
      2. **依次**将磁带中的用户作业读入主机执行
      3. 计算结果输入到输出机
      4. 当一批作业处理完之后重复上述步骤

      优点 : 减少了手动切换作业时间,克服了人机矛盾

      不足 : **在作业的输入和结果输出时,主机的高速`CPU`处于忙等状态,所以引入了脱机批处理**

   2. **脱机批处理系统** : 输入输出脱离主机控制

      ![1558918926092](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1558918926092.png)

      **卫星机的功能** :

      1. 从输入机中读取用户作业并放到输入磁带上
      2. 从输出磁带中读取执行结果并传回输出机

      优点 : **主机可以与卫星机并行**,主机不需要与慢速的输入输出设备打交道,直接与高速磁带机交互,输入输出有卫星机控制

      不足 : **在主机中每次存放一道作业,在其运行期间发生`I/O`请求后高速`CPU`要等待低速`CPU`完成操作,处于空闲状态,所以引入了多道程序系统**

## 集成电路与多道程序设计

1. 定义 : 允许多个程序同时进入内存并运行,允许他们交替使用计算机资源,**当一个因`I/O`请求暂停时,将`CPU`资源分配给另一个程序**

2. **单处理机(即单核`CPU`)中多道程序运行** :

   1. 宏观上并行 : 均开始运行,均未结束运行
   2. 微观上串行 : 轮流使用`CPU`交替运行

3. 多道批处理系统 :

   * 多道 : 系统外存中容纳多个作业,由系统选择调度
   * 成批 : 作业进入系统后不允许用户干扰

   优点 : 系统吞吐量大,资源利用率高

   不足 : 平均周转周期长,**不能提供交互能力** (所以提出了**分时系统**)

## 分时系统

侧重点在于**交互性(即对用户请求的及时响应)**

1. 定义: 将`CPU`处理时间分割成多个时间片,将不同时间片分配给不同的程序达到程序同时运行的效果

2. 特点 :

   * 多路性 : 允许多个用户同时使用一台计算机,微观上轮流使用,宏观上用户并行使用

   * 交互性 : 根据请求响应

   * 独立性 : 各用户之间相互独立,互不干扰

   * 及时性 : 由**响应时间**衡量 : 从终端发出指令到系统给予应答的时间

     其影响因素有系统开销,用户数目,时间片长短,对换信息量等,通过**可重入代码,引入虚存减少对换**缩短

```flow
elem1=>start: 计算机
aim1=>operation: 解决人机矛盾
elem2=>start: 联机批处理
aim2=>operation: 解决输入输出时CPU处于忙等
elem3=>start: 脱机批处理
aim3=>operation: 解决单个作业I/O请求导致CPU等待
elem4=>start: 多道程序批处理
aim4=>operation: 解决交互性问题
elem5=>end: 分时系统
elem1(right)->aim1->elem2->aim2->elem3->aim3->elem4->aim4->elem5
```

**注意在选择设计时要注意需求**,例如 :

1. 对于大规模作业使用批处理
2. 对于对快速响应的交互性使用分时系统

## 异常

![1558923044094](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1558923044094.png)

**系统调用** : 系统调用把应用程序的请求传给内核，调用相应的的内核函数完成所需的处理，将处理结果返回给应用程序

## 操作系统的基本类型

1. 批处理系统
2. 分时系统
3. 实时系统
4. 混合型

## 操作系统的特征

* 并发
* 共享
* 虚拟
* 不确定

## 操作系统要解决的问题

1. 提供解决由资源竞争引起的各种冲突的策略
2. 协调并发活动
3. 保证数据的一致性
4. 实现数据的存取控制

## 操作系统的功能

* 处理机管理 : 进程的控制,同步,通信,调度
* 存储器管理 : 内存分配.内存保护,地址映射
* 设备管理 : 缓冲管理,设备分配,设备处理,虚拟设备
* 文件系统 : 文件读写,文件保护,用户接口

## 微内核结构

内核中只包含中断处理,进程通信,基本调度等功能,文件系统,内存管理,设备管理均以服务的形式在微内核中使用

# 启动

## 引导加载程序(Bootloader)

系统加电之后运行的第一段代码,一般分为两个阶段

1. `Boot` : 初始化一部分系统硬件使其运行(一般汇编,与体系结构关联)
2. `Loader` : 将操作系统映像加载到内存中并把控制权交给操作系统(一般`C`,可移植)

## MIPS启动

### 内存划分

![1558925513343](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1558925513343.png)

1. `kseg0`放操作系统核心,(存取经过`cache`),最高位清0映射
2. `kseg1`与`kseg0`映射到同一个物理空间(高三位清0映射),存取不经过`cache`,**`kseg1`是唯一在系统启动时可以使用的空间**

### 启动过程

```flow
st=>start: 上电
op1=>operation: Bootloader加载操作系统
op2=>operation: 操作系统引导
st->op1->op2
```

# 内存管理

## 大小端问题

![1559132509033](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559132509033.png)

## 存储管理基本概念

### 存储管理功能

* 存储分配与回收
* 地址变换
  1. 可执行文件生成时的链接技术
  2. 程序加载时的重定位技术
  3. 进程运行时的硬件与软件地址变化技术
* 存储共享与保护
* 存储器扩充

### 可执行文件

1. 可执行文件的生成 :

   1. 编译 : 由**源文件**编译为**目标文件**
   2. 链接 : 由**目标文件**链接为可执行文件,**本质就是把目标文件相同类型的`section`合并为可执行文件的一个`segement`**

   **在链接时,会在各个目标文件中填入缺省(即编译时未找到)的函数地址,这个过程就是重定位** :

   1. 在编译过程中会**记录未找到的定义所在的偏移量在符号表中**
   2. 在链接过程中会**遍历每个目标文件的符号表在全局范围内查找缺失定义**

2. 一个程序**在内存中**的构成 :

   1. `bss`段 : 未初始化的全局变量(**不再可执行文件中,由系统初始化**)
   2. `data`段 : 已经初始化的全局变量
   3. `text`段 : 代码段
   4. 堆 : 存放运行中动态分配的内存段
   5. 栈 : 存放,交换临时数据(局部变量)的内存区

3. 可执行文件的装载 :

   将`ELF`文件中`Type`为`Load`的`segement`加载到内存的指定位置

   **一个`segememt`在文件中的大小是小于等于其在内存中的大小的,多余的空间以补0填充**

   **可执行文件的装载中也存在重定向过程,本质是因为一个程序本身有自己的逻辑空间,但是加载到内存中去后又有物理地址,二者要契合就要进行修改或者映射**

### 重定向

1. 链接过程中 : 填写编译时没有找到定义的变量或者函数的地址
2. 加载过程中 : 对目标程序中的指令和数据地址的修改或映射过程
   * 静态重定位
   * 动态充定位

## 存储管理的目标

1. 从用户角度可以支配整个存储空间
2. 从计算机角度可以同时为多个用户提供服务

## 存储管理的原则

1. **地址独立** : 程序发出的地址与物理地址无关 
2. **地址保护** : 一个程序不能访问另一个程序的地址

## 基础物理内存管理

### 存储分配方式

* 直接指定 : 程序中的是实际地址
* 静态分配 : 程序在存储空间中的地址**在装入时**确定
* 动态分配 : 程序在存储空间中的地址**在装入时**确定,并且在执行过程中可以申请空间,在使用完之后可以释放

### 单道程序内存管理

1. **前提条件** : 
   * 内存中只有两个程序,用户程序与操作系统
   * 操作系统占据的空间固定
2. 管理方式 : **静态地址翻译**
   * 用户程序永远**加载到同一个指定位置**
   * 在**程序运行前可以计算出所有的物理地址(由加载器完成)**
3. 优点 : 无需地址翻译,运行速度快
4. 缺点 : 
   * 比物理内存大的程序无法加载运行
   * 单个程序占据资源造成资源浪费

### 多道程序内存管理

管理方式 : **分区式分配**

将内存分成**大小相等或者不等的分区**,其中操作系统占据一个,每个用户程序占据一个或者多个

#### 固定式分区

1. 划分方式 : 
   * 分区大小相等
   * 分区大小不等 : 多个小分区,适量中等分区,少量大分区
2. 分配方式 :
   * 单一队列 : 多个用户程序**排在一个队列中**等待分区
   * 多队列 : 给每个分区一个队列,**程序根据大小排在相应的队列中**
3. 优点 : 简单易于实现,开销小
4. 缺点 : 
   * **内碎片浪费**
   * 分区数目**限定了程序并发执行的数目**
5. **管理内存的数据结构**
   1. 位图表示法 : **每个分配单元使用一位来表示**
      - 优点 : 空间成本固定,与程序数目无关,操作简单
      - 缺点 : 没有容错能力
   2. 链表表示法 : **将分配单元按照是否空闲链接,一个节点为一个程序占据的连续分区数目或者为连续的空闲分区**
      - 优点 : 可以容错
      - 缺点 : 空间成本取决于内存中程序的数目,操作时间成本高

#### 可变式分区

1. 划分方式 : 分区的大小可以变换
2. 分配方式 : **依据程序的加载逐渐分配**
3. 优点 : **没有内碎片**
4. 缺点 : **有外碎片**
5. 管理内存的数据结构 : **已分配分区表与未分配分区表**
   * 每张表的表项为存储控制块
   * **空闲分区表的存储控制块使用前向和后向指针组织成链表结构**

### 顺序搜索的分配算法

在**分区表**结构下顺序搜索,使用于较小的系统(否则分区表很大)

**注意在分配之后一个分区的剩下空间仍然可以继续分配出去**

* 首次适应算法 : 低地址区域留下众多小的空闲分区
* 下次适应算法 : 
  1. 是存储空间的利用更加均衡,不致于在一端
  2. 导致缺失大的空闲分区
* 最佳适应算法 :使剩余的空闲区非常小,很难利用
* 最坏适应算法 : 当有大作业到来时申请很难被满足

### 索引搜索的分配算法

1. 将空闲分区按照容量大小分类
2. 对每个类别建立空闲区链表
3. 为多个空闲链表设立一张管理索引表

### 系统的碎片

1. 内部碎片 : 分配给作业中未被利用的部分,例如固定分区中存在的碎片
2. 外部碎片 : 系统中太小而无法利用的空闲分区,例如动态分区管理
3. 处理外部碎片 : **紧凑技术** , 通过移动作业将多个分散的小分区(外部碎片)拼接成一个大分区(通过动态重定位解决)

### 覆盖与交换

1. 目的 : **在多道程序环境下扩充内存,即在小的内存空间运行大程序**
2. 手段 :
   * 覆盖 : 将程序**划分为功能独立(即不用同时装入内存运行)的片段**,将这些片段**逐步装入内存中,**这种方式不对用户透明(即需要用户显式的实现)
   * 交换 : 将暂时不用的数据转移到辅存中去,交换由操作系统管理,对用户不可见

## 页式内存管理

1. 基本思想 : **将逻辑地址连续的程序分散存放在若干物理上不连续的内存区域内**,即保证程序的正确运行,又可以充分利用物理内存

2. 实现 :

   * 将程序的逻辑地址按页面大小分成若干页
   * 将内存的物理地址按页面大小分成若干存储块(页框)
   * 通过**页表**结构实现映射

3. 页面大小的选择 :

   * 页面较小 : 

     1. 优点 : 减少页内碎片和总的内存碎片,提高内存利用率

     2. 缺点 : 每个进程的页面数增多导致页表项占据空间增大

        页面换进换出速度降低(这块是为什么??)

   * 页面较大 : 

     1. 优点 : 每个进程的页面数减少导致页表项占据空间较小

        页面换进换出速度提高

     2. 缺点 : 增加页内碎片,不利于提高内存利用率 

4. 页表

   * **页表位于内存中,属于进程的现场信息**
   * 页表的**基址与长度**由页表寄存器给出

5. 地址转换

   ![1559132045925](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559132045925.png)

6. **多级页表**

   * 设计需求 : 当逻辑地址很大时只使用一级页表页表会占据很大的**连续**空间,实现起来很困难,使用多级页表解决该问题

     (其实还可以通过动态向内存中调入页表来解决)

   * 通常使用**二级页表(即页目录 + 页表)**

   ![1559132329372](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559132329372.png)

7. **快表** : 页表的`cache`

   ![1559132596083](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559132596083.png)

8. **访存流程** 

   注 : 页表的作用是**虚拟地址转换为物理地址**

   ​		内存`Cache`的作用是根据**物理地址**查找**地址存储内容**

   1. 根据虚拟地址查找`TLB`

   2. 若命中则得到物理地址

      如没有命中则访问页表获得物理地址

   3. 根据物理地址访问内存`Cache`

   4. 若命中则返回地址存储内容

      若没有命中则访问物理内存获得地址存储内容

9. 哈希页表 : 

   适用于**逻辑地址空间较大的情况,用来减少页表项占据的连续空间大小**

   通过哈希映射将多个虚拟页号映射到表中的一项

   1. 对一个虚拟地址**使用虚拟页号生成哈希值**
   2. 每一个页表项包括虚拟页号,映射到的物理页号,指向下一个项的指针
   3. 在使用时对链上的页表项逐个比较

   ![1559133517857](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559133517857.png)

10. **反置页表**

    * 设计需求 : 当逻辑地址空间过大时页表项占据的内存空间过大,**为了降低页表项占据的空间**

    * 实现 : **使用物理页号来组织页表**,所以页表大小只与物理内存大小有关

      **每个页表项中包含进程号与逻辑页号**

    * 缺点 : 查找速度慢,很难实现内存**共享**

    * 使用 : 

      1. 在根据逻辑地址检索时**要遍历整个页表进行比较**

         ![1559134283152](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559134283152.png)

      2. 可以通过**哈希表的结构避免逐个检索** :

         1. 使用虚拟页号**通过哈希表映射到一个物理页号**(注意由于哈希关系一个物理页号可能对应多个虚拟页号的哈希值,所以这里找到的**只是反置页表项链的头**)
         2. 遍历反置页表项链,逐个与虚拟地址比较,确定是哪一个页表项
         3. **通过页表项在反置页表中的位置获得物理地址**

         ![1559134601038](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559134601038.png)

## 段式内存管理

1. 基本思想 : 按照程序**的逻辑进行分段,并按照段来存储在内存中**

2. 好处 : 

   * 信息保护 : 在页式中**可能会有一页中部分共享部分保护的情况无法处理**,在段式中**以信息的最小逻辑单元进行保护**
   * 动态增长 : 某些段的大小会增长
   * 动态链接

3. 使用 : 基本与页式相同,利用**段表**

4. **与页式比较** : 

   **页是信息的最小物理单元,段是信息的最小逻辑单元**

   ![1559135753617](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559135753617.png)

## 段页式内存管理

1. 基本思想 : **用分段方法来分配和管理虚拟存储器,而用分页方法来分配和管理实存储器**

2. 实现 :

   1. **将用户进程分成若干段,每段再分成若干页**
   2. 每个进程**一个段表,每个段一张页表**

   ![1559135969604](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559135969604.png)

## 虚拟存储管理

1. 依据 : **局部性原理** :

   * 时间局部性
   * 空间局部性

2. 特征 : 

   * 离散性
   * 多次性
   * 对换性
   * 虚拟性

3. 调入问题 : 将程序与数据(OS和用户程序)调入内存

   * 何时 :
     1. OS在系统启动时调入
     2. 用户程序**取决于调入策略** :
        * 预调页 
        * 按需调页
   * 如何调入 : **缺页处理机制**

4. **页面置换策略** 

   * 最优置换(`OPT`) : 无法实现.理论比较实用,**置换掉未来最久不会被使用的页**

   * 先进先出(`FIFO`) : **将页面按调入时间顺序组织成队列,置换掉最旧的页面**

     注 : 可能出现`Belay`现象 : 可供使用的页面数增多,但缺页率反而上升

   * 第二次机会(`Second Chance`) : **当队列中最旧的页面在进入队列之后会被使用过,则将其移动到队尾,清除使用标记,判断下一个**

   * `最近未使用(Clock`) : **使用环形队列组织页面**

     1. 如果没有缺页错误,将指向页面的访问位置为1
     2. 如果有缺页错误,当前指向某个页面 
        * 若页面访问位为1,则**清除访问位,指向下一个**
        * 若页面访问位为0,则**替换该页**

   * 最近最少使用(`LRU`) : **使用栈结构组织页**

     当进程访问某页面,则**将其页号从栈中取出放在栈顶,则每次替换选取栈底那一页**

5. 更新问题(内存与磁盘数据的一致性)

   * 写回 : **只有在替换页面时向磁盘写回数据**
   * 写直达 : **每次更改都写回磁盘**

6. 









