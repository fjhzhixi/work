# 引论

## 操作系统定义

操作系统是一组管理计算机硬件资源的软件集合,向计算机程序提供共性的服务

* 对**使用者**提供用户与硬件系统的接口方便使用
* 作为**资源管理者**控制和管理各种软硬件资源提高利用率
* 合理组织计算机系统的工作流程,改善系统性能

**操作系统的设计目标**也就对应着 :

1. 使使用者方便
2. 使系统的资源利用率尽可能高

## 系统层次

1. 自顶向下看 : 管理复杂的硬件资源,**使用抽象屏蔽复杂性**
2. 自底向上看 : 向上层应用提供服务,支持多个用户,多个程序,实现资源的共享

## 作用

1. 用户与计算机硬件系统之间的接口
2. 系统资源的管理者
3. 实现对计算机资源的抽象(虚拟机)

## 冯诺依曼计算机的主要特点

**存储程序**思想 :

1. 计算机应用包括运算器、控制器、存储器、输入/输出设备.
2. 计算机内部应采用二进制来表示指令和数据
3. 将程序和数据送会内存储器，然后计算机自动地逐条取出指令和数据进行分析、处理和执行。

之后的哈佛结构改进将**程序指令与数据分开存储**

## 晶体管时代的批处理系统

又名监控系统,**主要解决了高速`CPU`与低速`I/O`设备之间的矛盾**

1. 定义 : 将用户提交的作业成批送入计算机,由作业调度程序自动选择作业运行

2. 目的 : 

   * 缩短作业之间的交接时间
   * 减少处理机的空闲等待,提高系统效率

3. **发展阶段** : 

   1. **联机批处理系统 ** : 作业的输入输出由主机`CPU`来处理

      ![1558918643435](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1558918643435.png)

      在批处理系统的控制下 : 

      1. **成批**的将输入机上的用户作业读入磁带中
      2. **依次**将磁带中的用户作业读入主机执行
      3. 计算结果输入到输出机
      4. 当一批作业处理完之后重复上述步骤

      优点 : 减少了手动切换作业时间,克服了人机矛盾

      不足 : **在作业的输入和结果输出时,主机的高速`CPU`处于忙等状态,所以引入了脱机批处理**

   2. **脱机批处理系统** : 输入输出脱离主机控制

      ![1558918926092](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1558918926092.png)

      **卫星机的功能** :

      1. 从输入机中读取用户作业并放到输入磁带上
      2. 从输出磁带中读取执行结果并传回输出机

      优点 : **主机可以与卫星机并行**,主机不需要与慢速的输入输出设备打交道,直接与高速磁带机交互,输入输出有卫星机控制

      不足 : **在主机中每次存放一道作业,在其运行期间发生`I/O`请求后高速`CPU`要等待低速`CPU`完成操作,处于空闲状态,所以引入了多道程序系统**

## 集成电路与多道程序设计

1. 定义 : 允许多个程序同时进入内存并运行,允许他们交替使用计算机资源,**当一个因`I/O`请求暂停时,将`CPU`资源分配给另一个程序**

2. **单处理机(即单核`CPU`)中多道程序运行** :

   1. 宏观上并行 : 均开始运行,均未结束运行
   2. 微观上串行 : 轮流使用`CPU`交替运行

3. 多道批处理系统 :

   * 多道 : 系统外存中容纳多个作业,由系统选择调度
   * 成批 : 作业进入系统后不允许用户干扰

   优点 : 系统吞吐量大,资源利用率高

   不足 : 平均周转周期长,**不能提供交互能力** (所以提出了**分时系统**)

## 分时系统

侧重点在于**交互性(即对用户请求的及时响应)**

1. 定义: 将`CPU`处理时间分割成多个时间片,将不同时间片分配给不同的程序达到程序同时运行的效果

2. 特点 :

   * 多路性 : 允许多个用户同时使用一台计算机,微观上轮流使用,宏观上用户并行使用

   * 交互性 : 根据请求响应

   * 独立性 : 各用户之间相互独立,互不干扰

   * 及时性 : 由**响应时间**衡量 : 从终端发出指令到系统给予应答的时间

     其影响因素有系统开销,用户数目,时间片长短,对换信息量等,通过**可重入代码,引入虚存减少对换**缩短

```flow
elem1=>start: 计算机
aim1=>operation: 解决人机矛盾
elem2=>start: 联机批处理
aim2=>operation: 解决输入输出时CPU处于忙等
elem3=>start: 脱机批处理
aim3=>operation: 解决单个作业I/O请求导致CPU等待
elem4=>start: 多道程序批处理
aim4=>operation: 解决交互性问题
elem5=>end: 分时系统
elem1(right)->aim1->elem2->aim2->elem3->aim3->elem4->aim4->elem5
```

**注意在选择设计时要注意需求**,例如 :

1. 对于大规模作业使用批处理
2. 对于对快速响应的交互性使用分时系统

## 异常

![1558923044094](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1558923044094.png)

**系统调用** : 系统调用把应用程序的请求传给内核，调用相应的的内核函数完成所需的处理，将处理结果返回给应用程序

## 操作系统的基本类型

1. 批处理系统
2. 分时系统
3. 实时系统
4. 混合型

## 操作系统的特征

* 并发
* 共享
* 虚拟
* 不确定

## 操作系统要解决的问题

1. 提供解决由资源竞争引起的各种冲突的策略
2. 协调并发活动
3. 保证数据的一致性
4. 实现数据的存取控制

## 操作系统的功能

* 处理机管理 : 进程的控制,同步,通信,调度
* 存储器管理 : 内存分配.内存保护,地址映射
* 设备管理 : 缓冲管理,设备分配,设备处理,虚拟设备
* 文件系统 : 文件读写,文件保护,用户接口

## 微内核结构

内核中只包含中断处理,进程通信,基本调度等功能,文件系统,内存管理,设备管理均以服务的形式在微内核中使用

# 启动

## 引导加载程序(Bootloader)

系统加电之后运行的第一段代码,一般分为两个阶段

1. `Boot` : 初始化一部分系统硬件使其运行(一般汇编,与体系结构关联)
2. `Loader` : 将操作系统映像加载到内存中并把控制权交给操作系统(一般`C`,可移植)

## MIPS启动

### 内存划分

![1558925513343](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1558925513343.png)

1. `kseg0`放操作系统核心,(存取经过`cache`),最高位清0映射
2. `kseg1`与`kseg0`映射到同一个物理空间(高三位清0映射),存取不经过`cache`,**`kseg1`是唯一在系统启动时可以使用的空间**

### 启动过程

```flow
st=>start: 上电
op1=>operation: Bootloader加载操作系统
op2=>operation: 操作系统引导
st->op1->op2
```

# 内存管理

## 大小端问题

![1559132509033](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559132509033.png)

## 存储管理基本概念

### 存储管理功能

* 存储分配与回收
* 地址变换
  1. 可执行文件生成时的链接技术
  2. 程序加载时的重定位技术
  3. 进程运行时的硬件与软件地址变化技术
* 存储共享与保护
* 存储器扩充

### 可执行文件

1. 可执行文件的生成 :

   1. 编译 : 由**源文件**编译为**目标文件**
   2. 链接 : 由**目标文件**链接为可执行文件,**本质就是把目标文件相同类型的`section`合并为可执行文件的一个`segement`**

   **在链接时,会在各个目标文件中填入缺省(即编译时未找到)的函数地址,这个过程就是重定位** :

   1. 在编译过程中会**记录未找到的定义所在的偏移量在符号表中**
   2. 在链接过程中会**遍历每个目标文件的符号表在全局范围内查找缺失定义**

2. 一个程序**在内存中**的构成 :

   1. `bss`段 : 未初始化的全局变量(**不再可执行文件中,由系统初始化**)
   2. `data`段 : 已经初始化的全局变量
   3. `text`段 : 代码段
   4. 堆 : 存放运行中动态分配的内存段
   5. 栈 : 存放,交换临时数据(局部变量)的内存区

3. 可执行文件的装载 :

   将`ELF`文件中`Type`为`Load`的`segement`加载到内存的指定位置

   **一个`segememt`在文件中的大小是小于等于其在内存中的大小的,多余的空间以补0填充**

   **可执行文件的装载中也存在重定向过程,本质是因为一个程序本身有自己的逻辑空间,但是加载到内存中去后又有物理地址,二者要契合就要进行修改或者映射**

### 重定向

1. 链接过程中 : 填写编译时没有找到定义的变量或者函数的地址
2. 加载过程中 : 对目标程序中的指令和数据地址的修改或映射过程
   * 静态重定位
   * 动态充定位

## 存储管理的目标

1. 从用户角度可以支配整个存储空间
2. 从计算机角度可以同时为多个用户提供服务

## 存储管理的原则

1. **地址独立** : 程序发出的地址与物理地址无关 
2. **地址保护** : 一个程序不能访问另一个程序的地址

## 基础物理内存管理

### 存储分配方式

* 直接指定 : 程序中的是实际地址
* 静态分配 : 程序在存储空间中的地址**在装入时**确定
* 动态分配 : 程序在存储空间中的地址**在装入时**确定,并且在执行过程中可以申请空间,在使用完之后可以释放

### 单道程序内存管理

1. **前提条件** : 
   * 内存中只有两个程序,用户程序与操作系统
   * 操作系统占据的空间固定
2. 管理方式 : **静态地址翻译**
   * 用户程序永远**加载到同一个指定位置**
   * 在**程序运行前可以计算出所有的物理地址(由加载器完成)**
3. 优点 : 无需地址翻译,运行速度快
4. 缺点 : 
   * 比物理内存大的程序无法加载运行
   * 单个程序占据资源造成资源浪费

### 多道程序内存管理

管理方式 : **分区式分配**

将内存分成**大小相等或者不等的分区**,其中操作系统占据一个,每个用户程序占据一个或者多个

#### 固定式分区

1. 划分方式 : 
   * 分区大小相等
   * 分区大小不等 : 多个小分区,适量中等分区,少量大分区
2. 分配方式 :
   * 单一队列 : 多个用户程序**排在一个队列中**等待分区
   * 多队列 : 给每个分区一个队列,**程序根据大小排在相应的队列中**
3. 优点 : 简单易于实现,开销小
4. 缺点 : 
   * **内碎片浪费**
   * 分区数目**限定了程序并发执行的数目**
5. **管理内存的数据结构**
   1. 位图表示法 : **每个分配单元使用一位来表示**
      - 优点 : 空间成本固定,与程序数目无关,操作简单
      - 缺点 : 没有容错能力
   2. 链表表示法 : **将分配单元按照是否空闲链接,一个节点为一个程序占据的连续分区数目或者为连续的空闲分区**
      - 优点 : 可以容错
      - 缺点 : 空间成本取决于内存中程序的数目,操作时间成本高

#### 可变式分区

1. 划分方式 : 分区的大小可以变换
2. 分配方式 : **依据程序的加载逐渐分配**
3. 优点 : **没有内碎片**
4. 缺点 : **有外碎片**
5. 管理内存的数据结构 : **已分配分区表与未分配分区表**
   * 每张表的表项为存储控制块
   * **空闲分区表的存储控制块使用前向和后向指针组织成链表结构**

### 顺序搜索的分配算法

在**分区表**结构下顺序搜索,使用于较小的系统(否则分区表很大)

**注意在分配之后一个分区的剩下空间仍然可以继续分配出去**

* 首次适应算法 : 低地址区域留下众多小的空闲分区
* 下次适应算法 : 
  1. 是存储空间的利用更加均衡,不致于在一端
  2. 导致缺失大的空闲分区
* 最佳适应算法 :使剩余的空闲区非常小,很难利用
* 最坏适应算法 : 当有大作业到来时申请很难被满足

### 索引搜索的分配算法

1. 将空闲分区按照容量大小分类
2. 对每个类别建立空闲区链表
3. 为多个空闲链表设立一张管理索引表

### 系统的碎片

1. 内部碎片 : 分配给作业中未被利用的部分,例如固定分区中存在的碎片
2. 外部碎片 : 系统中太小而无法利用的空闲分区,例如动态分区管理
3. 处理外部碎片 : **紧凑技术** , 通过移动作业将多个分散的小分区(外部碎片)拼接成一个大分区(通过动态重定位解决)

### 覆盖与交换

1. 目的 : **在多道程序环境下扩充内存,即在小的内存空间运行大程序**
2. 手段 :
   * 覆盖 : 将程序**划分为功能独立(即不用同时装入内存运行)的片段**,将这些片段**逐步装入内存中,**这种方式不对用户透明(即需要用户显式的实现)
   * 交换 : 将暂时不用的数据转移到辅存中去,交换由操作系统管理,对用户不可见

## 页式内存管理

1. 基本思想 : **将逻辑地址连续的程序分散存放在若干物理上不连续的内存区域内**,即保证程序的正确运行,又可以充分利用物理内存

2. 实现 :

   * 将程序的逻辑地址按页面大小分成若干页
   * 将内存的物理地址按页面大小分成若干存储块(页框)
   * 通过**页表**结构实现映射

3. 页面大小的选择 :

   * 页面较小 : 

     1. 优点 : 减少页内碎片和总的内存碎片,提高内存利用率

     2. 缺点 : 每个进程的页面数增多导致页表项占据空间增大

        页面换进换出速度降低(这块是为什么??)

   * 页面较大 : 

     1. 优点 : 每个进程的页面数减少导致页表项占据空间较小

        页面换进换出速度提高

     2. 缺点 : 增加页内碎片,不利于提高内存利用率 

4. 页表

   * **页表位于内存中,属于进程的现场信息**
   * 页表的**基址与长度**由页表寄存器给出

5. 地址转换

   ![1559132045925](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559132045925.png)

6. **多级页表**

   * 设计需求 : 当逻辑地址很大时只使用一级页表页表会占据很大的**连续**空间,实现起来很困难,使用多级页表解决该问题

     (其实还可以通过动态向内存中调入页表来解决)

   * 通常使用**二级页表(即页目录 + 页表)**

   ![1559132329372](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559132329372.png)

7. **快表** : 页表的`cache`

   ![1559132596083](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559132596083.png)

8. **访存流程** 

   注 : 页表的作用是**虚拟地址转换为物理地址**

   ​		内存`Cache`的作用是根据**物理地址**查找**地址存储内容**

   1. 根据虚拟地址查找`TLB`

   2. 若命中则得到物理地址

      如没有命中则访问页表获得物理地址

   3. 根据物理地址访问内存`Cache`

   4. 若命中则返回地址存储内容

      若没有命中则访问物理内存获得地址存储内容

9. 哈希页表 : 

   适用于**逻辑地址空间较大的情况,用来减少页表项占据的连续空间大小**

   通过哈希映射将多个虚拟页号映射到表中的一项

   1. 对一个虚拟地址**使用虚拟页号生成哈希值**
   2. 每一个页表项包括虚拟页号,映射到的物理页号,指向下一个项的指针
   3. 在使用时对链上的页表项逐个比较

   ![1559133517857](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559133517857.png)

10. **反置页表**

    * 设计需求 : 当逻辑地址空间过大时页表项占据的内存空间过大,**为了降低页表项占据的空间**

    * 实现 : **使用物理页号来组织页表**,所以页表大小只与物理内存大小有关

      **每个页表项中包含进程号与逻辑页号**

    * 缺点 : 查找速度慢,很难实现内存**共享**

    * 使用 : 

      1. 在根据逻辑地址检索时**要遍历整个页表进行比较**

         ![1559134283152](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559134283152.png)

      2. 可以通过**哈希表的结构避免逐个检索** :

         1. 使用虚拟页号**通过哈希表映射到一个物理页号**(注意由于哈希关系一个物理页号可能对应多个虚拟页号的哈希值,所以这里找到的**只是反置页表项链的头**)
         2. 遍历反置页表项链,逐个与虚拟地址比较,确定是哪一个页表项
         3. **通过页表项在反置页表中的位置获得物理地址**

         ![1559134601038](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559134601038.png)

## 段式内存管理

1. 基本思想 : 按照程序**的逻辑进行分段,并按照段来存储在内存中**

2. 好处 : 

   * 信息保护 : 在页式中**可能会有一页中部分共享部分保护的情况无法处理**,在段式中**以信息的最小逻辑单元进行保护**
   * 动态增长 : 某些段的大小会增长
   * 动态链接

3. 使用 : 基本与页式相同,利用**段表**

4. **与页式比较** : 

   **页是信息的最小物理单元,段是信息的最小逻辑单元**

   ![1559135753617](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559135753617.png)

## 段页式内存管理

1. 基本思想 : **用分段方法来分配和管理虚拟存储器,而用分页方法来分配和管理实存储器**

2. 实现 :

   1. **将用户进程分成若干段,每段再分成若干页**
   2. 每个进程**一个段表,每个段一张页表**

   ![1559135969604](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559135969604.png)

## 虚拟存储管理

1. 依据 : **局部性原理** :

   * 时间局部性
   * 空间局部性

2. 特征 : 

   * 离散性
   * 多次性
   * 对换性
   * 虚拟性

3. 调入问题 : 将程序与数据(OS和用户程序)调入内存

   * 何时 :
     1. OS在系统启动时调入
     2. 用户程序**取决于调入策略** :
        * 预调页 
        * 按需调页
   * 如何调入 : **缺页处理机制**

4. **页面置换策略** 

   * 最优置换(`OPT`) : 无法实现.理论比较实用,**置换掉未来最久不会被使用的页**

   * 先进先出(`FIFO`) : **将页面按调入时间顺序组织成队列,置换掉最旧的页面**

     注 : 可能出现`Belay`现象 : 可供使用的页面数增多,但缺页率反而上升

   * 第二次机会(`Second Chance`) : **当队列中最旧的页面在进入队列之后会被使用过,则将其移动到队尾,清除使用标记,判断下一个**

   * `最近未使用(Clock`) : **使用环形队列组织页面**

     1. 如果没有缺页错误,将指向页面的访问位置为1
     2. 如果有缺页错误,当前指向某个页面 
        * 若页面访问位为1,则**清除访问位,指向下一个**
        * 若页面访问位为0,则**替换该页**

   * 最近最少使用(`LRU`) : **使用栈结构组织页**

     当进程访问某页面,则**将其页号从栈中取出放在栈顶,则每次替换选取栈底那一页**

5. 更新问题(内存与磁盘数据的一致性)

   * 写回 : **只有在替换页面时向磁盘写回数据**
   * 写直达 : **每次更改都写回磁盘**

6. 工作集与驻留集

   * 工作集 : 当前某一进程正在使用的页面的集合,**与程序的局部性有关**

   * 驻留集 : 虚拟存储系统中**为该进程分配的物理页框集合**

   * **驻留集分配策略** : 

     1. 考虑因素 : 给每个进程分配的物理页框数越少,同时驻留在内存中的进程数越多,**有利于进程调度**,但是对单个进程而言**缺页率会越高**

     2. 分配策略 : 

        * 固定分配策略 : 为每个活跃进程分配固定的页框数

        * 可变分配策略 : **根据进程运行期间的缺页率调整驻留集大小**

          缺页率高则增大驻留集,缺页率小则回收驻留集

   * **页面置换策略** : 

     1. 局部置换 : 进程**在自己的驻留集中寻找页框置换**
     2. 全局置换 : 进程**在整个内存空间寻找页框置换**
     3. **全局置换的问题是进程不能控制自己的缺页率,他受其他进程影响**
     4. **固定分配策略不能搭配全局替换策略**

7. 抖动问题 : 

   1. 现象 : 随着内存中的驻留进程数目的增加,`CPU`的利用率**先上升后下降**,这个下降就是抖动问题
   2. 原因 : 随着进程数增加,每个进程的**驻留集减小**,当驻留集小于工作集时,**由于频繁的缺页置换(表现为频繁的磁盘IO)导致`CPU`利用率下降**
   3. 减弱 :
      * 使用局部置换策略
      * 预留部分页面
      * 挂起若干进程

8. 页面清除策略 :

   **决定系统何时将被置换的页面写回到外存中**

   1. 直接写回 : 频繁双向`IO`耗时
   2. **页面缓冲算法** : 先将置换的页面保存在缓冲区中,之后统一写回磁盘(还可以方便下次再用到)

# 进程与线程

## 基本概念

1. **区分并发与并行** :

   * 并发 : 考察的是一个时间段内二者都运行,即某刻二者后处于开始到结束的某一处即可
   * 并行 : 考察任意时刻二者都要同时运行,**即需要多个处理器**

2. **区分程序的顺序执行和并发执行的特征**

   * 顺序执行 : 
     1. 顺序性
     2. 封闭性 : 独占所有的资源
     3. 可再现性
   * 并发执行 :
     1. 间断性
     2. 非封闭性 : 多个进程共享资源
     3. 不可再现性

3. **竞争** : 多个进程在读写**共享数据**时结果依赖于他们的**执行的相对时间**的情况

4. 进程 : 是一个程序及其数据在处理机上顺序执行的动态活动

   **进程是系统进行资源分配和调度的一个独立单元**

   **进程与程序不是一一对应的** :

   * 通过多次执行,一个程序可以对应多个进程
   * 通过调用关系,一个进程可以包括多个程序

5. 原语 : **由若干条指令所组成的指令序列,来实现某个特定的操作功能**

   * 指令序列执行是连续而不可分割的
   * 是操作系统的核心组成部分,必须在内核态下执行,并且常驻内存

6. **进程的状态及状态转换** :

   ![1559223969959](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559223969959.png)

   ![1559223979754](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559223979754.png)

7. **进程控制块的组织形式**

   * 线性表 : 将所有的控制块连续的存放在内存的系统区,适用于系统中进程数目不多的情况
   * 索引方式 : 按照**进程的状态分别建立就绪索引表,阻塞索引表等结构**
   * 链接方式 : 按照**进程的状态构建就绪队列,阻塞队列,运行队列等**

8. 线程 : **进程包含资源拥有者和可执行单元,其中可执行单元作为线程**

   **同一进程的线程享有同一地址空间**

   **线程是`CPU`调度和分配的单元**

9. **进程与线程** :

   * 进程是资源分配的基本单元,线程是处理机调度的基本单元
   * 线程共享进程的数据资源,**但拥有自己的栈**
   * 线程由于**资源共享**很容易协作同步,但是进程的同步需要**消息通信机制**


## 进程同步与互斥(安全性)

1. **临界资源** : 一次仅允许(保证正确运行)一个进程访问的资源

   临界区 : 每个进程中访问临界资源的那段代码

2. 进程的**同步与互斥**

   1. 互斥(间接制约关系) : 多个进程**不能同时进入同一组共享变量的临界区域,否则可能会发生与时间有关的错误**
   2. 同步(直接制约关系) : 系统的各个进程对资源**进行有序的访问**,使得结果符合设计者的**逻辑**

3. 临界区的管理 :

   * 空闲让进
   * 忙则等待
   * 有限等待 : 对要求访问的在有限的时间内保证进入
   * 让权等待 : 进程长时间无法进入应释放`CPU`

4. 实现进程互斥 : 

   * 软件方法 : **面包店算法** 

   * 硬件方法 : 

     1. **中断屏蔽** : 执行关中断之后进入临界区,退出临界区之前开中断

     2. 使用**不可被中断**的基本原语指令`test and set` : 写值到某个内存位置并返回其旧值

     3. 使用**不会被中断的**基本原子`swap`指令 : 交换两个字的内容

        在`MIPS`中使用`LL和SC`这两条汇编完成 :

        1. `LL` : 从内存中读出一个字,**处理器会记录这次操作**
        2. `SC` : **会检查上次`LL`之后是否对该内存内容进行修改,若没有修改则向该内存中写入值并设寄存器值为1,否则不写入值并设寄存器值为0**

   * 问题 :

     1. **解决互斥的基本思想** : 当一个进程想进入临界区时,检查是否可以进入,若不可以则原地等待直到可以为止
     2. **问题** :
        * 忙等严重
        * 优先级反转 : 高优先级等待低优先级

5. 基于**信号量**实现同步互斥

   1. **信号量结构** : 

      * 一个非负初值的整形变量 :
        1. 初始值为**资源的个数**
        2. **值>=0时表示资源的个数,<0时表示等待进程的个数**
      * 一个初始状态为空的队列 : **当有进程阻塞到该资源上时进入阻塞队列**

   2. 操作 :

      * `P`操作 : 
        1. 含义 : 向进程分配资源
        2. 操作 : **信号量先减1,若之后值<0,则阻塞该进程**
      * `V`操作 :
        1. 含义 : 释放资源
        2. 操作 : **信号量先加1,若之后<=0,则从阻塞队列中拿出一个进程分配资源运行**

   3. **应用**

      注意**`P,V`操作成对出现,在进入临界区之前使用`P`操作,退出临界区之后使用`V`操作**

      * 互斥 : 使用**初始值为1**的信号量

      * 有限并发 : 对拥有`n`个资源使用初始值为`n`的信号量

      * **进程同步** : 

        ![1559281444122](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559281444122.png)

        1. 设置**初始值为0**
        2. 要求后执行的**在执行前使用`P`操作**
        3. 要求先执行的**在执行后使用`V`操作**

   4. 信号量集机制 :

      **对信号量进行扩展解决多个共享资源的互斥访问**

      1. `AND`型信号量集 : `SP(S1, S2,....Sn) SV(S1, S2,....Sn)`

         将进程需要的所有资源一次分配给他(如果都可以的话),在进程结束之后一起释放

      2. 一般信号量机制 : `SP(S1,t1,d1...) SV(S1,d1...)` 

         **当Si < ti时不予分配,否则一次分配di个**

6. 管程 : 

   1. 组成结构 : 

      * 共享的数据
      * 对数据互斥的操作(只有这些操作可以改变管程中数据)

   2. 使用机制 : 

      * **同一时间只有一个进程可以操作管程实现互斥**
      * **入口等待队列** : 由于管程**互斥进入**导致在**管程外**等待的进程独立
      * **紧急等待队列** : 由于在**管程内部**唤醒一个进程会导致**自身等待**,这种进程加入在**管程内的紧急等待队列**
      * 每个共享资源自身有一个等待队列

   3. 操作 :

      * `x.wait()` : 将**该进程放入x的等待队列尾**, 

        如果紧急等待队列非空,则唤醒第一个,否则唤醒入口等待队列第一个

      * `x.signal()` : 将**该进程放入紧急等待队列尾**

        如果x资源的等待队列不为空,则唤醒第一个

7. 进程间通信 :

   **主要包括三种方式 : 管道,共享内存,消息系统**

   其中共享内存最有用,最快,共享内存可以同时读但是不可以同时写

## 进程调度

1. 进程占用`CPU`的形式 :
   * 非抢占式 : 进程一直占用处理器直达自身调用原语,等待IO陷入阻塞,或者时间片用完
   * 抢占式 : 当就绪队列中有优先级更高的进程时,立即切换到优先级较高的

**决定采用何种调度方式取决于该系统的特性与需求要求**

1. 批处理系统的调度的**衡量标准**

   ![1559286242643](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559286242643.png)

   * 先来先服务(`FCFS`) : 

     按照**作业提交的先后顺序**以**非抢占的形式**顺序执行

   * 短作业优先(`SJF`) :

     按照**已经提交的作业序列中的执行时间递增**以**非抢占式**顺序执行

   * 最短剩余时间优先(`FRTF`) :

     **将`SJF`改为抢断式**, 当一个新就绪的进程比**当前运行的进程有更短的完成时间则抢占当前进程**

     即在每次有进程就绪时更新一次执行顺序

   * 最高响应比优先(`HRRF`) 

     ![1559286777920](C:\Users\fjh\AppData\Roaming\Typora\typora-user-images\1559286777920.png)

2. 交互式系统的调度算法

   * 时间片轮转算法 : **关键在于时间片长度的选择**
   * 多级队列算法 : 根据进程的优先级组织成多个队列

3. 实时系统的调度算法

   **实时系统的参数含义** :

   1. 任务到达时间`t`
   2. **周期`T`** : 含义为**自任务到达开始,每一个周期内最多执行一次任务**
   3. 执行时间`c` : 执行一次任务所需的时间
   4. 截止周期`D` : 含义为每个周期从开始计算的**最晚完成时间**, 通常`D = T`

   * 单调速率调度`RMS` :
     1. 任务的周期小的优先级高
     2. 优先级高的最先被调度,相同优先级则随机选择一个
     3. **注意切换的时机有一个任务执行完,或者该时刻有更高优先级的任务开始新一轮周期的执行**
     4. **抢占式调度**
   * 最早截止期优先(`EDF`) :
     1. 任务的**绝对截止(即基于当前执行情况到该周期截止时间的距离)时间越早,优先级越高**
     2. 选取优先级高的进程**可抢占式调度**

## 死锁

1. 定义 : 由于资源占用的互斥,当某个进程提出资源申请之后使得**某些进程在无外力协助下永远分配不到必需的资源而无法运行**

2. 产生原因 :

   * 竞争资源
   * 并发的顺序不当

3. 资源的种类 : 

   * 可剥夺资源 : 可以被其他进程剥夺 : 例如`CPU`,内存等
   * 非可剥夺资源 : 不可被其他进程强行收回,只能自己使用完释放
   * 临时性资源 : 一个进程产生后被另一个进程使用,例如消息

4. **死锁发生的必要条件**

   * 互斥条件 : 对申请到的资源排他性使用
   * 请求和保持条件 : 进程已经**至少拥有一个资源**,由于请求另一个**被其他进程占用的资源**而阻塞自身
   * 不可剥夺条件 : 进程自身的资源不可被其他进程剥夺,只能由自身使用完之后释放
   * 环路等待条件 : 存在继承资源的环形链

5. 处理死锁的方法 :

   1. 不允许死锁发生 :

      * 预防死锁(**静态**) : 打破**死锁的必要条件**

        1. 打破互斥条件 : 对部分资源允许同时访问
        2. 打破占有且申请条件 : 当**系统满足当前进程的全部资源请求时**才一次性分配 (预测难,资源利用率低,并发性差)
        3. 打破不可剥夺条件 : 允许进程强行从占有者处剥夺资源
        4. 打破循环等待条件 : 对所有**资源种类按顺序编号**,进程占用了小号资源,才可以申请大号资源

      * 避免死锁(**动态** ) : **对进程的每一个申请做动态的检查来看是否安全**

        **银行家算法**

   2. 允许死锁发生之后解决

      * 检测死锁 : **资源分配图算法**
      * 解除死锁 : 
        1. 撤销进程
        2. 剥夺资源

# IO管理

1. 外设管理的目的(即需求) :

   * 提高效率 : 匹配快速`CPU`与慢速外设
   * 方便使用 : 对不同类型外设向用户展示统一接口
   * 方便控制 : `OS`对外设的控制

2. 外设管理要实现的**功能** :

   * 提供设备使用的**用户接口**
   * 设备分配与释放
   * 设备的访问与控制
   * `I/O`的缓冲与调度

3. 接入`I/O`设备的主要方式是总线

4. IO设备管理包括**逻辑IO,设备驱动程序,中断服务程序**

5. IO硬件组成

   IO的硬件设备**抽象为控制器**

   * 控制器 : 数据寄存器,控制寄存器,状态寄存器

   * IO端口地址 : 每个寄存器**有唯一的地址** :

     1. 内存映像编址形式 : IO寄存器作为物理内存空间的一部分

        **注意不允许对IO寄存器地址的数据进行高速缓存**

     2. IO独立编址 : 对应IO专用指令

6. IO控制方式 :

   **基本思路是减少CPU对IO过程的控制,使之独立于CPU运行,让CPU和外设都保持较高的利用率**

   * 程序控制IO : 轮询方式,CPU向IO发出指令之后自身忙等等待IO操作完成之后继续进行
   * 中断驱动 : 当IO操作结束后由设备控制器主动通知设备驱动程序IO结束
   * 直接存储器访问方式(`DMA`) : 有一个专门的控制器来完成数据在内存与设备之间的**成批**传输
   * 通道 : 一个专门控制数据输入输出的**处理器**, 有自己的指令集

7. IO软件

   **层次化的设计思想** : 硬件IO, 基于硬件的设备驱动程序,与硬件无关的OS程序,用户层次的IO接口

   * 设备独立性 : 逻辑设备名到物理设备名 : 逻辑设备表`LUT`
   * **设备驱动程序** :
     1. 与设备结构密切相关
     2. 任务是**接受来自与设备无关的上层软件的抽象请求,并执行**
     3. 通过操作**设备寄存器**实现

8. 缓冲技术

   * 作用 : **提高外设利用率** 
     1. 匹配CPU与外设之间的不同处理速度
     2. 减少对CPU的中端次数
     3. 提高CPU与IO设备之间的并行性
   * 类型 :
     1. 单缓冲
     2. 双缓冲
     3. 环形缓冲
     4. 缓冲池

9. IO设备管理 :

   * `SPOOLing1技术`

10. IO性能问题 :

    * 提高途径 :
      1. **使CPU利用率尽可能不被IO降低**
      2. **使CPU尽可能摆脱IO**

11. IO操作类型 :

    IO操作分**两段** :

    1. 磁盘将数据装载进内核的内存空间
    2. 内核的内存空间中的数据复制到用户的内存空间

    **IO操作的种类**

    * 阻塞IO :  在IO系统调用结果返回之前,当前进程**被挂起**,直到结果返回之后继续进行

    * 非阻塞IO : 在IO系统调用发出之后IO**通知进程进行别的操作**,进程**反复通过系统调用查询IO是否完成**

    * IO多路复用 : 阻塞IO,处理一个**进程有多种类型的IO请求的情况**

    * 事件(信号)驱动型IO : **第一阶段非阻塞,第二阶段阻塞**

      进程发起调用,一旦第一阶段完成后**CPU通知进程**,之后执行第二段

    * 异步IO : **两段都是异步的** ,只有当数据完全复制到用户进程**CPU才通知进程**

