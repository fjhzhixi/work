# 第一次作业

## 设计

第一次的傻瓜电梯设计十分平凡,没有使用任何算法策略

1. 类设计:
   1. `Elevator`类 : 表示电梯的状态,控制电梯的运行.
   2. `Elevator(Thread)`类 : 模拟电梯运行的线程类
   3. `Main(Thread)`类 : 主类控制输入

   *此处应该有个图*

2. 多线程分析:

   1. 共享对象 : 由`Elevator`类与`Main`类共享一个请求队列
   2. 安全性保障 : 自定义类`RequestQueue`为一个线程安全类,其中的方法都定义为`synchronized`的加锁方法
   3. 设计模式 : 采用生产者-消费者模式来阻止类

# 第二次作业

## 设计

第二次的电梯要求支持随层捎带

1. 算法策略 : 使用`SSTF`作为基本策略,详细如下 :

   1. 选择主请求策略 : 

      * 当电梯中没有乘客时,选择距离自己最近的请求来作为主请求
      * 当电梯中有乘客时,选择执行最早完成的请求作为主请求
      * 电梯在每一层都检查是否可以更新主请求

   2. 添加捎带请求策略 : 

      * 可捎带判定 : 起始于电梯目前层,目标楼层与当前主请求的目标楼层在当前同一侧
      * 电梯在每一层检查该层是否有可捎带的指令,若有则加入电梯执行对列

   3. 电梯运动控制 :

      * 电梯的运行控制仅与当前主请求方向有关
      * 电梯按层运行
      * 电梯的开关门操作取决于是否有可捎带以及是否有乘客出去

   4. 算法流程图示

      *此处应当有个图*

2. 类设计

   1. `RequestQueue` : 线程安全的请求队列类
   2. `Elevator` : 电梯类,保存电梯状态
   3. `Passenger` : 乘客类,保存乘客的行为
   4. `Scheduler` : 调度器类,负责
      * 选择主请求.
      * 判断是否有捎带请求.
      * 给电梯发送运行指令
   5. `Elevator(Thread)` : 模拟电梯运行的类
   6. `Main(Thread)` : 模拟输入的类

   *此处应该有个图*

3. 多线程分析 :

   1. 共享对象 : 只有输入线程与模拟电梯线程共享一个请求队列
   2. 安全性保障 : 
      * 设计`RequestQueue`本身为线程安全的类
      * 此外,由于在调度器中包含大量的逻辑代码来判断主请求和捎带请求,所以在遍历队列来选择的时候要对请求队列加锁,保证逻辑选择的正确性
   3. 设计模式 :
      * 输出线程与电梯线程共享请求队列采用生产者-消费者模型
      * 电梯与其中的乘客采用订阅者模式

# 第三次作业

## 设计

此次作业在第二次的基础上扩展为3中不同的电梯

1. 算法策略(主要是分配指令的算法,单部电梯的运行算法与第二次无异)

   由于一些时间关系,我没有采用过于复杂的优化算法,只进行了一些静态的优化

   1. 对指令进行分类 :

      * 可以由一步电梯直达的指令

        判断进出楼层是否在同一个电梯来决定是否可以直达

        1. 由于进出层都是奇数层的可能性比较小,所以优先使用`C`电梯
        2. 然后由于`A`电梯比较快,所以次之使用`A`电梯
        3. 当前2条都不满足时,再使用`B`电梯

      * 必须由两部电梯共同完成的指令









