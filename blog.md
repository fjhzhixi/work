# 第一次作业

## 设计策略

第一次的傻瓜电梯设计十分平凡,没有使用任何算法策略

1. 类设计:
   1. `Elevator`类 : 表示电梯的状态,控制电梯的运行.
   2. `ElevatorThread(Thread)`类 : 模拟电梯运行的线程类
   3. `Main(Thread)`类 : 主类控制输入

   *elevator1*

2. 多线程分析:

   1. 共享对象 : 由`Elevator`类与`Main`类共享一个请求队列
   2. 安全性保障 : 自定义类`RequestQueue`为一个线程安全类,其中的方法都定义为`synchronized`的加锁方法
   3. 设计模式 : 采用生产者-消费者模式来阻止类

   *time1*

## 基于度量分析程序结构

## 分析自己的程序bug

第一次作业在公测和互测中均未被发现bug

# 第二次作业

## 设计策略

第二次的电梯要求支持随层捎带

1. 算法策略 : 使用`SSTF`作为基本策略,详细如下 :

   1. 选择主请求策略 : 

      * 当电梯中没有乘客时,选择距离自己最近的请求来作为主请求
      * 当电梯中有乘客时,选择执行最早完成的请求作为主请求
      * 电梯在每一层都检查是否可以更新主请求

   2. 添加捎带请求策略 : 

      * 可捎带判定 : 起始于电梯目前层,目标楼层与当前主请求的目标楼层在当前同一侧
      * 电梯在每一层检查该层是否有可捎带的指令,若有则加入电梯执行对列

   3. 电梯运动控制 :

      * 电梯的运行控制仅与当前主请求方向有关
      * 电梯按层运行
      * 电梯的开关门操作取决于是否有可捎带以及是否有乘客出去

   4. 算法流程图示

      *choose1*

2. 类设计

   1. `RequestQueue`类 : 线程安全的请求队列类
   2. `Elevator`类 : 电梯类,保存电梯状态
   3. `Passenger`类 : 乘客类,保存乘客的行为
   4. `Scheduler`类 : 调度器类,负责
      * 选择主请求.
      * 判断是否有捎带请求.
      * 给电梯发送运行指令
   5. `ElevatorThread(Thread)`类 : 模拟电梯运行的类
   6. `Main(Thread)`类 : 模拟输入的类

   *elevator2*

3. 多线程分析 :

   1. 共享对象 : 只有输入线程与模拟电梯线程共享一个请求队列

   2. 安全性保障 : 
      * 设计`RequestQueue`本身为线程安全的类
      * 此外,由于在调度器中包含大量的逻辑代码来判断主请求和捎带请求,所以在遍历队列来选择的时候要对请求队列加锁,保证逻辑选择的正确性

   3. 设计模式 :
      * 输出线程与电梯线程共享请求队列采用生产者-消费者模型
      * 电梯与其中的乘客采用订阅者模式

      *time2*

## 基于度量分析程序结构

## 分析自己的程序bug

在第二次作业中在公测与互层中出现了一个由于逻辑混乱导致的bug

1. 产生原因 : 在控制电梯运行时通过比较当前楼层与目标楼层决定运行方向使用`if-else`结构时将二者相等的情况误算入到向下运行导致电梯运行到-4这一不存在的楼层
2. 修复 : 在控制层次对三种情况分开讨论即可,即加入相等的情况

# 第三次作业

## 设计策略

此次作业在第二次的基础上扩展为3种不同的电梯

1. 算法策略(主要是分配指令的算法,单部电梯的运行算法与第二次无异)

   由于一些时间关系,我没有采用过于复杂的优化算法,只进行了一些静态的优化算法

   1. 对指令进行分类 :

      * 可以由一步电梯直达的指令

        判断进出楼层是否在同一个电梯来决定是否可以直达

        1. 由于进出层都是奇数层的可能性比较小,所以优先使用`C`电梯
        2. 然后由于`A`电梯比较快,所以次之使用`A`电梯
        3. 当前2条都不满足时,再使用`B`电梯

      * 必须由两部电梯共同完成的指令

        1. 分析题目要求我认为设置1,15层为中转层比较合理
        2. 3层比较特殊只有`C`电梯可以到达所以要特殊考虑
        3. 要考虑拆分为两条指令后的执行顺序问题，即要保证乘客先出电梯再进行下一步接送

   2. 对控制进行分层

      1. 第二次设计中的调度器主要负责单个电梯的运行,维护单个电梯的指令队列
      2. 加入一个总调度器控制三个子调度器,其主要功能是从输入的总指令队列分发指令到三个子调度器的指令队列

2. 类设计 : 在第二次的基础上添加和修改了部分类

   1. `Elevator`类 : 增加名字,可达楼层,最大载客量,运行速度等属性
   2. `SchedulerAll`类 : 增加总控制器类,负责将指令分发给具体控制电梯运行的子控制器

   *elevator3*

3. 多线程分析:

   1. 共享对象 : [主线程(控制输入) + 总调度器] 与 三个[电梯线程 + 子调度器] 分别共享一个电梯的执行请求队列
   2. 安全性保障 : 由于只是量变,本质上还是两个线程共享一个线程安全队列的问题,安全性的保障框架完全继承与第二次作业.

## 基于度量分析程序结构

## 分析自己的程序bug

第三次作业在公测与互测中均未被发现bug

# 测试方法

# 心得体会















