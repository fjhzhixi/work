# lab4做了什么

## 支持缺页中断处理

## 完成基本的系统调用

我觉得系统调用的实质就是用户态的进程想使用一些内核态下的功能,比如分配内存空间,创建进程等等,但是由于操作系统要保障**安全性**,所以这些接口不能向用户程序开放,所以采用一个折中的方法,即**系统调用**,用户将一些必要的信息以**参数的形式**传递给内核,内核判断你的操作是否**合法**,合法则执行并将结果返回给用户,否则拒绝执行

## 实现fork

`fork`就是**以父进程为模板**创建一个与其**高度相似**的子进程,其关键的一点特性是**父子进程中的`fork`返回值不同**,这也是区分父子进程的方法

## 实现进程间通信

通信本质上就是**在进程间传递一个数值**, 通过**共享内存**来实现, 共享的是所有进程都存在的内核中的2G空间中的一个位置

# 提前准备的知识

## MIPS下C与汇编的参数传递

# 走进lab4

## 系统调用的基本流程

### 宏观上看一个系统调用的过程

1. 调用一个封装好的用户空间的库函数
2. 调用用户空间的syscall_* 函数
3. 调用msyscall，用于陷入内核态
4. 陷入内核，内核取得信息，执行对应的内核空间的系统调用函数（sys_*）
5. 执行系统调用，并返回用户态，同时将返回值“传递”回用户态
6. 从库函数返回，回到用户程序调用处

### 代码细节



# 问题

1. fork.c中的duppage传递的父进程号不一定是0吧
2. 

